// у каждого значения есть Owner
// в каждый момент времени у значения может быть один Owner
// значение удаляется когда Owner покидает Scope

pub fn main() {
    {
        let _s = "hello";
        // строковый литерал иммутабелен,
        // его размер известен заранее,
        // он хранится в сегменте данных
    }
    // тут _s пропадает

    {
        let _s = String::from("hello");
        // String (а не &str) мутабелен,
        // значение помещается в heap,
        // а ссылка на значение в stack

        // _s.push('!');
        // cannot mutate immutable variable `_s`
    }
    // тут _s пропадает, а память очищается
    // вызывается ф-я drop

    {
        let mut _s = String::from("hello");
        _s.push('!');
    }
    // тут _s пропадает, а память очищается

    {
        let _x = 5;
        let _y = _x;
        // оба значения поместятся в stack
        // оба значения будут доступны
        // _x - 5, _y - 5
        // println!("_x - {}, _y - {}", _x, _y);
    }

    {
        let _s1 = String::from("hello");
        // значение поместится в heap,
        // String это
        // - name
        // - ptr - указатель на heap
        // - len
        // - capacity
        // эта информация хранится в Stack

        let _s2 = _s1;
        // копируются ptr, len и capacity
        // данные в куче не копируются, т.е.
        // ptr указывает туда же

        // _s1 считается более недействительной
        // borrow of moved value: `_s1`
        // println!("{}", _s1);

        // это поверхностное (shallow) копирование
    }

    {
        // если необходимо глубокое (deep) копирование, то
        // необходимо сделать это явно
        let _s1 = String::from("hello");
        let _s2 = _s1.clone();

        // s1 = hello, s2 = hello
        // println!("s1 = {s1}, s2 = {s2}");

        // clone - дорогая операция
    }
}
